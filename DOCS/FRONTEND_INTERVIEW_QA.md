# 🎨 フロントエンド面接対策：強めの質問回答集

「なぜそう実装したか？」に答えられるように、仕様と理由をセットで記述しています。

---

## Q1. 画面とユーザーフロー
**🗣️ 回答:**
1.  **イベント確認**: トップページ（`/home`）にカレンダーが表示され、日付ごとの「●」マークでイベントの有無を確認します。日付をクリックすると、その日のイベント詳細がモーダルウィンドウで表示されます。
2.  **参加投票**: モーダル内に「参加する / 不参加」ボタンがあり、タップすると即座にボタンの色が変わり（Optimistic UI）、参加済み状態になります。
    *   *ポイント*: 詳細ページに遷移せず、モーダル内で完結させることで操作の手数を減らしています。
3.  **当日チェックイン**: イベント当日のみ、モーダル内の詳細に「QRを表示 (Admin)」または「QRを読み込む」ボタンが出現します。カメラが起動し、会場のQRを読むとチェックイン完了（出席扱い）になります。

---

## Q2. カレンダーUIの実装
**🗣️ 回答:**
*   **実装方法**: ライブラリは使わず、**自作のJavaScript (`calendar.js`) と Djangoのテンプレート変数** を組み合わせて実装しました。
*   **理由**: FullCalendar等のライブラリは便利ですが、「スマホでのタップしやすさ」や「イベントチップの詳細なデザイン（●マークの表示条件など）」を細かく制御したかったため、軽量な自作実装を選びました。
*   **データ形式**: Djangoからテンプレートに `events_json` (JSON) として以下の形式で渡しています。
    ```json
    {
      "start": "2024-10-01T18:00:00",
      "title": "練習",
      "color": "#e74c3c"
      // ...
    }
    ```
*   **表示切り替え**: 基本は「月表示」のみです。スマホ画面という制約上、週/日表示に切り替えるよりも、タップした日付の詳細を大きくモーダルで見せる方が見やすいと判断しました。

---

## Q3. 状態管理 (参加ボタン等)
**🗣️ 回答:**
*   **管理方法**: サーバーサイドの真の値（Database）と、DOM上の属性（`data-attending="true"`）およびCSSクラスで管理しています。
*   **更新ロジック**: ReactやVueのような仮想DOMは使わず、**Vanilla JSでDOMを直接操作**しています。
*   **Optimistic UI (楽観的UI)**: 「参加ボタン」を押した瞬間、APIのレスポンスを待たずにまずボタンの色を変え（`inactive` クラスのトグル）、ユーザーに「反応した」と感じさせます。その後、非同期通信の結果で確定させます。
*   **チェックイン連携**: `checked_in_at` の有無は、ページロード時にサーバーサイドレンダリングでバッジ（✅）としてHTMLに埋め込んで表示しています。

---

## Q4. 通信設計 (API)
**🗣️ 回答:**
*   **通信手段**: ブラウザ標準の **Fetch API** を使用しています（jQueryなどは不使用）。
*   **APIエンドポイント**: `/api/events/<id>/vote/` のようなRESTライクな設計です。
*   **レスポンス処理**:
    *   **成功 (200 OK)**: JsonResponseで `{ attending: true, count: 5 }` のように新しい状態と「最新の参加人数」を受け取り、表示を更新します。
    *   **失敗 (403/500)**: `try...catch` で捕捉し、UIを元の状態に戻した上で `alert('エラーが発生しました')` を出します。特に「イベント終了後の投票」などは403エラーとして適切にハンドルしています。

---

## Q5. UX（体験設計）の工夫
**🗣️ 回答:**
1.  **モーダル完結**: 一覧⇔詳細のページ遷移をなくし、文脈を維持したまま操作できるようにしました。
2.  **タップ領域の拡大**: スマホ操作を前提に、カレンダーの日付セル自体を大きくし、当たり判定を広げています。
3.  **状態の可視化**: 参加しているイベントはカレンダー上で色が濃くなるなど、一目で「自分の予定」がわかるようにCSSを工夫しています。
4.  **ロード時間の短縮**: 初回表示はSSR（サーバーサイド）で完成されたHTMLを返すため、ローディングスピナーを見せる待ち時間がほぼありません。

---

## Q6. バリデーションの責務分担
**🗣️ 回答:**
*   **分担ポリシー**: 「UXのためのチェックはフロント、データの整合性はバックエンド」と明確に分けています。
*   **フロントエンド (UX)**:
    *   HTML5の `required` 属性や `type="email"` を使い、送信ボタンを押す前に「入力漏れ」を即座に通知します。
    *   カレンダーなどで「未来の日付しか選べない」などのUI制御を行います。
*   **バックエンド (信頼性)**:
    *   Djangoの `Form` クラスや `Model` の制約を使用します。
    *   **理由**: フロントエンドのチェックはDevToolsなどで簡単に回避できてしまうため、最終的なデータ保護（重複チェック、権限チェック、イベント終了時刻の判定など）は必ずサーバー側で行っています。

---

## Q7. セキュリティ (CSRF対策)
**🗣️ 回答:**
*   **基本対策**: Djangoの標準機能である `CSRF Token` を全面的に使用しています。
*   **Fetch APIでの送信**: クッキー (`js-cookie` 等は使わず自作関数 `getCookie`) から `csrftoken` を取得し、Fetchリクエストのヘッダーに `'X-CSRFToken': token` を付与して送信しています。
*   **権限管理**: ログイン必須ページには `@login_required` をかけ、非ログインユーザーにはそもそもHTML（ボタンや入力欄）を見せない制御をしています。

---

## Q8. スマホ前提のUI設計
**🗣️ 回答:**
*   **レスポンシブ**: CSSの `@media query` で `768px` をブレークポイントに設定し、PCでは2カラム、スマホでは1カラムに可変させます。
*   **親指操作エリア**: 「保存ボタン」や「参加ボタン」などの重要アクションは、スマホを持ったときに親指が届きやすい画面下部やモーダル内に配置しています。
*   **PWA対応**: アドレスバーを消して画面を広く使えるように `manifest.json` を設定し、ネイティブアプリに近い操作感を実現しました。

---

## Q9. パフォーマンス (件数増加対策)
**🗣️ 回答:**
*   **サーバーサイド**: Djangoの `N+1問題` を `select_related` や `annotate` で解消し、JSON生成を高速化しています。
*   **取得範囲の制限**:
    *   現状は「全件取得」ですが、将来的に数百件を超えた場合は、カレンダーの「月移動ボタン」を押したタイミングで、その月のデータだけをFetchする **「遅延ロード (Lazy Loading)」** に切り替える設計を想定しています。
*   **レンダリング**: イベント数が増えても、DOMの再描画範囲を「クリックされた日付のセルだけ」等に限定し、ブラウザのReflowを最小限に抑えています。

---

## Q10. 保守性 (コード構造)
**🗣️ 回答:**
*   **テンプレート継承**: `base.html` に共通のヘッダー・フッター・ナビゲーションを集約し、各ページはコンテンツのみを記述する `{% extends %}` 構造にしています。
*   **CSS設計**: Bootstrapは使わず、**CSS変数 (`:root { --brand-color: ... }`)** で色や数値を一元管理しています。これにより、「テーマカラーを変えて」と言われても1行の変更で全ページに反映できます。
*   **JSの分離**: HTML内にスクリプトを書かず、`static/js/` に外出しして管理しています。機能ごとにファイル（`calendar.js`, `service-worker.js`）を分け、責務を明確にしています。
